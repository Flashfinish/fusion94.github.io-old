<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arduino | My Octopress Blog]]></title>
  <link href="http://fusion94.github.io/blog/categories/arduino/atom.xml" rel="self"/>
  <link href="http://fusion94.github.io/"/>
  <updated>2013-11-12T16:45:45-08:00</updated>
  <id>http://fusion94.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom Character Generator for LCD Panels]]></title>
    <link href="http://fusion94.github.io/blog/2013/02/01/custom-character-generator-for-lcd-panels/"/>
    <updated>2013-02-01T07:23:00-08:00</updated>
    <id>http://fusion94.github.io/blog/2013/02/01/custom-character-generator-for-lcd-panels</id>
    <content type="html"><![CDATA[<p>In a blog post coming later today or at the very latest on Monday I&rsquo;ll be writing about displaying content and custom characters on a LCD Panel/LCD Keypad Shield.</p>

<p>As part of that upcoming blog post I&rsquo;m announcing a Custom Character Generator for LCD Panels.</p>

<p>You can play around with it <a href="http://fusion94.org/lcdchargen/">here</a>.</p>

<!-- more -->


<h3>Description</h3>

<p>The LCD Character Generator (LCDCHARGEN) is a custom character generator to use with LCD Panels and/or LCD Shields.</p>

<p>This has been tested to work with the <a href="http://www.dfrobot.com/index.php?route=product/product&amp;product_id=51#.UQvN06HDS0c">LCD Keypad Shield For Arduino</a> by <a href="http://dfrobot.com">DFRobot</a>.</p>

<p>Other 16x2 LCD Panels/Shields should also work.</p>

<h3>Source Code</h3>

<p>This was originally developed by <a href="https://github.com/omerk/lcdchargen">Omerk Kilic</a> but now is powered by my fork located <a href="https://github.com/fusion94/lcdchargen">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino + DF-BluetoothV3 Bluetooth module]]></title>
    <link href="http://fusion94.github.io/blog/2012/12/08/arduino-plus-df-bluetoothv3-bluetooth-module/"/>
    <updated>2012-12-08T13:27:00-08:00</updated>
    <id>http://fusion94.github.io/blog/2012/12/08/arduino-plus-df-bluetoothv3-bluetooth-module</id>
    <content type="html"><![CDATA[<div class="info">NOTE: This blog post is part of a series of blog posts on how to build electronic circuits. If you’re 
at all interested then please subscribe to the RSS feed.</div>


<h3>Background</h3>

<p>In this blog post we&rsquo;re going to deal with the <a href="http://www.dfrobot.com/index.php?route=product/product&amp;filter_name=TEL0026&amp;product_id=360#.UMODVpPjlnM">DF-BluetoothV3 Bluetooth module</a>
from DFRobot and how to integrate it into an Arduino.</p>

<p>This DF-Bluetooth module offers an affordable way to let your microcontroller talk to your Bluetooth
devices such as Bluetooth mobile phones, laptop, and Bluetooth adapter. The Bluetooth module provides
TTL level UART interface which is supported by almost every microcontroller in the market.</p>

<!-- more -->


<p>It is also designed to be compatible with most popular Arduino controller. Simply plug into Arduino
IO Expansion Shield, and the Bluetooth Arduino is ready to use.</p>

<p><strong>Key Specfications</strong></p>

<ul>
<li>Chips: CSR BC417143</li>
<li>Bluetooth Protocol: Bluetooth Specification v2.0 +EDR</li>
<li>Working Frequency: 2.4-2.48GHz unlicensed ISM Band</li>
<li>Modulation Mode: GFSK (Gaussian Frequency Shift Keying)</li>
<li>Power: ≤4dBm, Class 2</li>
<li>Transmission Distance: 20-30 in free space</li>
<li>Sensitivity: ≤-84 dBm at 0.1% BER</li>
<li>Transmission rate: Asynchronous: 2.1 Mbps (Max)/160 kbps; Synchronous: 1Mbps/1Mbps</li>
<li>Security: Authentication and encryption</li>
<li>Support profiles: Bluetooth serial port</li>
<li>LED indicator: LINK</li>
<li>Power Supply: +3.5V-+8V DC/50 mA</li>
<li>Working Temperature: -20°C-+55°C</li>
<li>Dimension: 43x19.3x11mm</li>
<li>Default serial setting: 9600/N/8/1</li>
<li>Default Pairing Code: 1234</li>
</ul>


<h3>What It Can Do</h3>

<p>DF-BluetoothV3 Bluetooth module uses a unique double-board design, it is beautiful and aims to
prevent electrostatic damage to the module. It is designed to have 2 DC power input, wide voltage
supply (3.5V ~ 8V) and 3.3V power supply, suitable for various applications. STATE LINK is indicated
by a clear and bright LED which is used to display module status and connection status (STATE state:
Search state (high 104ms 342ms 2.9Hz cycle flicker) connection status (high 104ms period 2s 0.5Hz
flashing), LINK state: paired ). It has build-in on-board antenna which provides high quality signals.</p>

<p>{% img /images/blog/bluetooth/bt1.png %}</p>

<p>DIP switch is designed to set the module status, LED Off to turn off the LINK light to enter power
saving mode, AT Mode allows the module to enter AT command mode, AT commands can modify the baud rate
and the master and slave mode.</p>

<ul>
<li>This module can also be used as a pair which provides a transparent serial data communication.</li>
<li>This module has been tested and compatible with most Bluetooth adapter in the market (Bluetooth dongle, including laptops and mobile phones).</li>
<li>This module has been tested and compatible with Android Phones.</li>
</ul>


<p><strong>Hardware Required</strong></p>

<p>There are two different hardware setups that I&rsquo;ve tested this on.</p>

<p><strong>Setup One</strong></p>

<ul>
<li>DF-BluetoothV3 Bluetooth module</li>
<li>DF-IO Expansion Shield for Arduino (v5)</li>
<li>Arduino Uno</li>
</ul>


<p>{% img /images/blog/bluetooth/setup_one.png %}</p>

<p><strong>Setup Two</strong></p>

<ul>
<li>DF-BluetoothV3 Bluetooth module</li>
<li>Romeo-All in one Controller (Arduino Compatible Atmega 328) (V1.0)</li>
</ul>


<p>{% img /images/blog/bluetooth/setup_two.png %}</p>

<div class="warning">Please note that when you use the Romeo-All in one Controller (Arduino Compatible Atmega 328) (V1.0) 
then you're going to have to install the <a href="http://www.ftdichip.com/Drivers/VCP.htm">FTDI Drivers</a>.</div>


<h3>Additional Setup Notes</h3>

<div class="info">When the DF-Bluetooth is used on Arduino, please make sure you disconnect the DF-Bluetooth module 
before uploading any code to your Arduino. It won’t burn your Arduino, but the uploading will fail as 
the DF-Bluetooth module occupying the TX/RX pins.</div>


<p>The next step is that making pairs between the computer and the Bluetooth module. By doing this, from
the computer  communicating with a Bluetooth module is now just simple serial communications.</p>

<p>Detail steps depend on the operating system. Followings are from Mac OS X. Choose the Set Up Bluetooth
Devices menu item. Select the Bluetooth_V3 item.</p>

<p>{% img /images/blog/bluetooth/bluetooth_setup.jpeg %}</p>

<p>The default passcode of the Bluetooth module is ’1234.’ When you are prompted use the passcode.</p>

<p>{% img /images/blog/bluetooth/passcode.jpeg %}</p>

<p>When the pairing is completed successfully the window below will be shown.</p>

<p>{% img /images/blog/bluetooth/pairing_sucess.jpeg %}</p>

<p><strong>The Code</strong></p>

<p>{% codeblock DF-BluetoothV3 Bluetooth module code for Arduino %}
/*</p>

<p> DF-BluetoothV3 Bluetooth module</p>

<p> Intefaces the DF-BluetoothV3 Bluetooth module with most Arduino contollers.</p>

<p> When the DF-Bluetooth is used on Arduino, please make sure you disconnect the
 DF-Bluetooth module before uploading any code to your Arduino. It won’t burn
 your Arduino, but the uploading will fail as the DF-Bluetooth module occupying
 the TX/RX pins.</p>

<ul>
<li>Copyright &copy; 2012 by Tony Guntharp. All Rights Reserved.</li>
<li>Licensed under the terms of the Apache Public License</li>
<li>Please see the LICENSE included with this distribution for details.</li>
</ul>


<p> */</p>

<p>void setup() {
  // Initialize serial communications: Set serial baud rate to 9600
  Serial.begin(9600);        <br/>
}</p>

<p>void loop() {
  // Print out our Hello World string followed by a newline
  Serial.print(&ldquo;Hello World from the DF-BluetoothV3 Bluetooth module&rdquo;);      <br/>
  Serial.println();
  // 1 second delay
  delay(1000);                <br/>
}
{% endcodeblock %}</p>

<p>At the end of uploading and running the code listed above you will start to see some serial output
like in the image below.</p>

<p>{% img /images/blog/bluetooth/bt_results.png %}</p>

<p><strong>Source Code</strong></p>

<p><a href="https://github.com/fusion94/DF-BluetoothV3_Arduino">Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino + Compass Module 3-Axis HMC5883L]]></title>
    <link href="http://fusion94.github.io/blog/2012/11/29/arduino-plus-compass-module-3-axis-hmc5883l/"/>
    <updated>2012-11-29T13:14:00-08:00</updated>
    <id>http://fusion94.github.io/blog/2012/11/29/arduino-plus-compass-module-3-axis-hmc5883l</id>
    <content type="html"><![CDATA[<div class="info">NOTE: This is a post in a series of blog posts on how to build electronic circuits. If you’re at 
all interested then please subscribe to the RSS feed.</div>


<h3>Background</h3>

<p>In this blogpost we&rsquo;re going to deal with the <a href="http://www.parallax.com/tabid/768/ProductID/779/Default.aspx">Compass Module 3-Axis HMC5883L</a> from Parallax and how to
integrate it into an Arduino.</p>

<p>The Compass Module 3-Axis HMC5883L is designed for low-field magnetic sensing with a digital interface.
This compact sensor fits into small projects such as UAVs and robot navigation systems.</p>

<!-- more -->


<p>The sensor converts any magnetic field to a differential voltage output on 3 axes. This voltage shift
is the raw digital output value, which can then be used to calculate headings or sense magnetic fields
coming from different directions. Example code in PBASIC, Spin, and C are provided in the downloads.</p>

<p><strong>Features:</strong></p>

<ul>
<li>Measures Earth’s magnetic fields</li>
<li>3-axis magnetoresistive sensor</li>
<li>Wide magnetic field range (+/-8 gauss)</li>
<li>1 to 2 degree compass heading accuracy</li>
<li>Precision in-axis sensitivity and linearity</li>
<li>I2C digital Interface</li>
<li>Fast 160 Hz maximum output rate</li>
<li>Designed for use with a large variety of microcontrollers with different voltage requirements</li>
</ul>


<p><strong>Application Notes:</strong></p>

<ul>
<li>Auto and personal navigation</li>
<li>UAV systems</li>
<li>Robotic navigation</li>
<li>Location-based services (LBS)</li>
</ul>


<p><strong>Key Specifications:</strong></p>

<ul>
<li>Power Requirements: 2.7 to 6.5 VDC</li>
<li>Communication Interface: I2C (up to 400 kHz)</li>
<li>Operating temperature: -22 to +185 °F (-30 to +85 °C)</li>
<li>Dimensions: 0.725 x 0.650 in (1.8 x 1.7 cm)</li>
</ul>


<h3>What It Can Do</h3>

<ul>
<li>Measures the earth’s magnetic field in three axes, with a 1–2 degree accuracy</li>
<li>Provides individual readings for each axis, which may be used separately or together for 3D calculations</li>
<li>Measures raw strength (gauss) of a nearby magnetic source</li>
</ul>


<p>The 3-Axis Compass module measures magnetic fields in three directions – or axes, labeled X, Y, and Z.
In its most simple form, the module can be used as a basic compass to find earth’s magnetic north.</p>

<p>The compass module can also sense the relative strength of a nearby magnetic source, such as those
caused by magnets or electric fields. As the sensor detects magnetism in three dimensions, it can
determine relative distance and direction to these sources.</p>

<p>{% img /images/blog/compass/Compass-2.png %}</p>

<p>Compasses are commonly uses with accelerometers, where the data from both the compass and
accelerometer can provide extended information.</p>

<p>One application of adding an accelerometer is to compensate for any tilt of the compass. As with
most any compass, the reading is affected if the compass is not level.</p>

<p><strong>Hardware Required</strong></p>

<ul>
<li>Arduino Board</li>
<li>(1) Compass Module 3-Axis HMC5883L</li>
<li>breadboard</li>
<li>hook-up wire</li>
</ul>


<p><strong>Circuit</strong></p>

<p>{% img /images/blog/compass/Compass-3.png %}</p>

<p>Connect the 5V and GND pins of the compass to the power and ground ports on the Arduino. Connect
analog pin 4 of the Arduino to the SDA (Data) out pin of the compass, and analog pin 5 to the SCL
(Clock) out pin.</p>

<p>The picture below shows you essentially how the circuit should be laid out.</p>

<p>{% img /images/blog/compass/Compass-6_0.png %}</p>

<p>Don’t forget that your Arduino must be connected to your computer in order for it to transmit serial
data and don’t forget to set the Baud Rate of your serial connection to be 9600.</p>

<p><strong>The Code</strong></p>

<p>{% codeblock Compass Module 3-Axis HMC5883L code for Arduino %}
/*
   Compass Module 3-Axis HMC5883L</p>

<p>   Read the Compass Module 3-Axis HMC5883L and prints them over the serial connection to the computer.</p>

<p>   The circuit:</p>

<pre><code>* SDA (Data) output of compass to analog pin 4
* SCL (Clock) output of compass to analog pin 5
* +V of accelerometer to +5V
* GND of accelerometer to ground
</code></pre>

<p>   created 29 Nov 2012
   by Tony Guntharp</p>

<p> */</p>

<h1>include</h1>

<h1>define Addr 0x1E               // 7-bit address of HMC5883 compass</h1>

<p>void setup() {
  Serial.begin(9600);
  delay(100);                   // Power up delay
  Wire.begin();</p>

<p>  // Set operating mode to continuous
  Wire.beginTransmission(Addr);
  Wire.write(byte(0x02));
  Wire.write(byte(0x00));
  Wire.endTransmission();
}</p>

<p>void loop() {
  int x, y, z;</p>

<p>  // Initiate communications with compass
  Wire.beginTransmission(Addr);
  Wire.write(byte(0x03));       // Send request to X MSB register
  Wire.endTransmission();</p>

<p>  Wire.requestFrom(Addr, 6);    // Request 6 bytes; 2 bytes per axis
  if(Wire.available() &lt;=6) {    // If 6 bytes available</p>

<pre><code>x = Wire.read() &lt;&lt; 8 | Wire.read();
z = Wire.read() &lt;&lt; 8 | Wire.read();
y = Wire.read() &lt;&lt; 8 | Wire.read();
</code></pre>

<p>  }</p>

<p>  // Print raw values
  Serial.print(&ldquo;X=&rdquo;);
  Serial.print(x);
  Serial.print(&ldquo;, Y=&rdquo;);
  Serial.print(y);
  Serial.print(&ldquo;, Z=&rdquo;);
  Serial.println(z);</p>

<p>  delay(500);
}
{% endcodeblock %}</p>

<p>At the end of uploading and running the code listed above you will start to see some serial output
like in the image below.</p>

<p>{% img /images/blog/compass/compass_results.png %}</p>

<p>Here’s a picture of the actual circuit built.</p>

<p>{% img /images/blog/compass/compass_circuit.png %}</p>

<p><strong>Source Code</strong></p>

<p><a href="https://github.com/fusion94/HMC5883L_Arduino">Github</a></p>

<p>In a follow up blog post I’ll discuss how you can use both the Compass Module 3-Axis HMC5883L in
conjunction with the Memsic 2125 Dual-axis Accelerometer to compensate for any tilt of the compass.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino + Memsic 2125 Dual-axis Accelerometer]]></title>
    <link href="http://fusion94.github.io/blog/2012/11/28/arduino-plus-memsic-2125-dual-axis-accelerometer/"/>
    <updated>2012-11-28T15:50:00-08:00</updated>
    <id>http://fusion94.github.io/blog/2012/11/28/arduino-plus-memsic-2125-dual-axis-accelerometer</id>
    <content type="html"><![CDATA[<div class="info">NOTE: This is a post in a series of blog posts on how to build electronic circuits. If you’re at 
all interested then please subscribe to the RSS feed.</div>


<h3>Background</h3>

<p>In this blogpost we&rsquo;re going to deal with the <a href="http://learn.parallax.com/KickStart/28017">Memsic 2125 Dual-axis Accelerometer</a> from Parallax and how to integrate
it into an Arduino.</p>

<p>The Memsic 2125 is a low cost, dual-axis thermal accelerometer capable of measuring tilt, acceleration, rotation,
and vibration with a range of ±3 g. For integration into existing applications, the Memsic 2125 is electrically
compatible with other popular accelerometers.</p>

<!-- more -->


<p>Memsic provides the 2125 in a surface-mount format. Parallax mounts the circuit on a through-hole providing all
I/O connections so it can easily be inserted on a breadboard or through-hole prototype area.</p>

<p><strong>Features:</strong></p>

<ul>
<li>Measures ±3 g on each axis</li>
<li>Simple pulse output of g-force for each axis</li>
<li>Convenient 6-pin 0.1" spacing DIP module</li>
<li>Analog output fo temperature (Tout pin)</li>
<li>Low current at 3.3 or 5 V operation: less than 4 mA at 5 VDC</li>
</ul>


<p><strong>Sample Applications:</strong></p>

<ul>
<li>Dual-axis tilt sensing for autonomous robotics applications</li>
<li>Single-axis rotational position sensing</li>
<li>Movement/Lack-of-movement sensing for alarm systems</li>
<li>R/C hobby projects such as autopilots</li>
</ul>


<p><strong>Key Specifications:</strong></p>

<ul>
<li>Power requirements: +3.3 to +5 VDC</li>
<li>Communication: TTL/CMOS compatible 100 Hz PWM output signal with duty cycle proportional to acceleration</li>
<li>Dimensions: 0.42 x 0.42 x 0.45 in (10.7 x 10.7 x 11.8 mm)</li>
<li>Operating temp range: 32 to +158 °F (0 to +70 °C)</li>
</ul>


<h3>What It Can Do</h3>

<ul>
<li>Measures tilt in two axes: forward and back, or side to side</li>
<li>Registers sudden changes in motion
*Detects even small amounts of vibration and motion</li>
</ul>


<p>The Memsic 2125 Dual-axis Accelerometer is sensitive to the gravitational pull of the earth, allowing it to measure
tilt, vibration, motion, and acceleration. The sensor provides independent outputs for two axes, labeled X and Y:</p>

<ul>
<li>The X axis measures tilt or acceleration forward and back (direction of arrow)</li>
<li>The Y axis measures tilt or acceleration side to side</li>
</ul>


<p>{% img /images/blog/memsic2125/Memsic2125-2.png %}</p>

<p>The Memsic 2125 module registers the constant pull of earth’s gravity. This is specified as 1g (g for gravity). For
the Memsic sensor, the value of 1g is always some positive number, and is about half way between the highest and
lowest readings the module is capable of reporting.</p>

<p>As a tilt sensor, the Memsic 2125 detects when the module is not level. The output of the sensor indicates the amount
of inclination. As a acceleration or vibration sensor, the sensor measures the g-forces acting on it. The greater the
g-force, the higher the acceleration or vibration.</p>

<p>The X and Y axis output of the Memsic 2125 is a pulse that has a period of (that is, it repeats) 100 times a second
(100 Hz). The width of the pulse represents the instantaneous g-force. By measuring the width of the pulse, you can
derive – with high accuracy – the g-force of either axis.</p>

<p>{% img /images/blog/memsic2125/Memsic2125-3.png %}</p>

<p><strong>Hardware Required</strong></p>

<ul>
<li>Arduino Board</li>
<li>(1) Memsic 2125 Accelerometer</li>
<li>breadboard</li>
<li>hook-up wire</li>
</ul>


<p><strong>Circuit</strong></p>

<p>{% img /images/blog/memsic2125/Mx2125_PINOUT.png %}</p>

<p>Use the small triangle on the Memsic to properly orient the sensor on your breadboard. Connect the 5V and GND pins
of the Memsic 2125 to the power and ground ports on the Arduino. Connect digital pin 2 of the Arduino to the X out
pin of the accelerometer, and digital pin 3 to the Y out pin.</p>

<p>The picture below shows you essentially how the circuit should be laid out.</p>

<p>{% img /images/blog/memsic2125/Memsic2125-7.png %}</p>

<p>Don&rsquo;t forget that your Arduino must be connected to your computer in order for it to transmit serial data and
don&rsquo;t forget to set the Baud Rate of your serial connection to be 9600.</p>

<p><strong>The Code</strong></p>

<p>{% codeblock Memsic 2125 two-axis accelerometer code for Arduino %}/*
   Memsic2125</p>

<p>   Read the Memsic 2125 two-axis accelerometer and prints them over the serial connection to the
   computer.</p>

<p>   The circuit:</p>

<pre><code>* X output of accelerometer to digital pin 2
* Y output of accelerometer to digital pin 3
* +V of accelerometer to +5V
* GND of accelerometer to ground

* Copyright (c) 2012 by Tony Guntharp. All Rights Reserved.
* Licensed under the terms of the Apache Public License
* Please see the LICENSE included with this distribution for details.
</code></pre>

<p> */</p>

<p> // these constants won&rsquo;t change:
const int xPin = 2;     // X output of the accelerometer
const int yPin = 3;     // Y output of the accelerometer</p>

<p>void setup() {
  // initialize serial communications:
  Serial.begin(9600);
  // initialize the pins connected to the accelerometer
  // as inputs:
  pinMode(xPin, INPUT);
  pinMode(yPin, INPUT);
}</p>

<p>void loop() {
  // variables to read the pulse widths:
  int pulseX, pulseY;
  // variables to contain the resulting accelerations
  int accelerationX, accelerationY;</p>

<p>  // read pulse from x- and y-axes:
  pulseX = pulseIn(xPin,HIGH);<br/>
  pulseY = pulseIn(yPin,HIGH);</p>

<p>  // convert the pulse width into acceleration
  // accelerationX and accelerationY are in milli-g&rsquo;s:
  // earth&rsquo;s gravity is 1000 milli-g&rsquo;s, or 1g.
  accelerationX = ((pulseX / 10) &ndash; 500) * 8;
  accelerationY = ((pulseY / 10) &ndash; 500) * 8;</p>

<p>  // print the acceleration
  Serial.print(accelerationX);
  // print a tab character:
  Serial.print(&ldquo;\t&rdquo;);
  Serial.print(accelerationY);
  Serial.println();</p>

<p>  delay(100);
}
{% endcodeblock %}</p>

<p>At the end of uploading and running the code listed above you will start to see some serial output like in the
image below.</p>

<p>{% img /images/blog/memsic2125/memsic2125_results.png %}</p>

<p>Here&rsquo;s a picture of the actual circuit built.</p>

<p>{% img /images/blog/memsic2125/layout.png %}</p>

<p>In a follow up blog post I&rsquo;ll discuss how by using additional math, you can use the values provided by the
accelerometer to convert to actual g-forces or degrees of tilt.</p>

<p><strong>Source Code</strong></p>

<p><a href="https://github.com/fusion94/Memsic2125_Arduino">Github</a></p>
]]></content>
  </entry>
  
</feed>
